//! Contains utility functions for storing durations of varied ranges and precisions on u32,
//! so as to save space when compared to `std::time::Duration` -- 96bits vs 32bits -> 3x saving.
//!
//! NOTE: The functions receiving `Duration` and returning `u32` will panic with overflow when the
//! provided duration exceeds the maximum range.

use std::{
    ops::Add,
    time::{Duration, SystemTime},
};


/// Returns a `u32` capable of representing 24 hours (or exactly 86399.99996 seconds) from a duration structure, with a precision
/// of ~20.117µs (exactly `1/((2^32)/86400)*1e6`µs).\
/// Notice, however, this function is not able to exactly represent regular durations like 17:00:00.0000 -- it will always
/// fall into the closest rounded approximation (in this case, 16:59:59.999993).\
/// For the reverse operation, see [micros_from_24h_u32()].\
/// See [u32_from_10µs_precision_duration()] for a precise 10µs time quantum.
pub /*const*/ fn u32_from_24h_duration(duration: &Duration) -> u32 {
    const NANOS_IN_TIME_QUANTUM: f64 = 1.0e9 / ((1u64<<32) as f64 / 86400.0);
    ((duration.as_nanos() as f64) / NANOS_IN_TIME_QUANTUM).round() as u32
}

/// Works like [u32_from_24h_duration()], but receives `hours`, `minutes`, `seconds` and `millis` individually.
pub /*const*/ fn u32_from_24h_hmsm(hours: u8, minutes: u8, seconds: u8, millis: u16) -> u32 {
    const MILLIS_IN_TIME_QUANTUM: f64 = 1.0e3 / ((1u64<<32) as f64 / 86400.0);
    ( ( ((hours as f64) * 3600.0 + (minutes as f64) * 60.0 + (seconds as f64)) * 1.0e3 + (millis as f64) ) / MILLIS_IN_TIME_QUANTUM ).round() as u32
}

/// Works like [u32_from_24h_hmsm()], but allows specifying the `micros` as well (from 1 to 1000).
pub /*const*/ fn u32_from_24h_hmsmm(hours: u8, minutes: u8, seconds: u8, millis: u16, micros: u16) -> u32 {
    const MICROS_IN_TIME_QUANTUM: f64 = 1.0e6 / ((1u64<<32) as f64 / 86400.0);
    ( ( ((hours as f64) * 3600.0 + (minutes as f64) * 60.0 + (seconds as f64)) * 1.0e6 + ((millis as f64) * 1.0e3 + (micros as f64)) ) / MICROS_IN_TIME_QUANTUM ).round() as u32
}

/// Works like [u32_from_24h_duration()], but allows specifying it as `micros_since_midnight` (from 0 to 86400'000'000-1).
pub /*const*/ fn u32_from_24h_micros(micros_since_midnight: u64) -> u32 {
    const MICROS_IN_TIME_QUANTUM: f64 = 1.0e6 / ((1u64<<32) as f64 / 86400.0);
    ( micros_since_midnight as f64 / MICROS_IN_TIME_QUANTUM ).round() as u32
}

/// Returns the number of microseconds from the 20.1165676116943359375µs time quantum u32 `duration` generated by [u32_from_24h_duration()]
pub /*const*/ fn micros_from_24h_u32(duration: u32) -> u64 {
    const MICROS_IN_TIME_QUANTUM: f64 = 1000000.0 / ((1u64<<32) as f64 / 86400.0);
    (duration as f64 * MICROS_IN_TIME_QUANTUM).round() as u64
}

/// Returns the `Duration` struct from the 20.1165676116943359375µs time quantum u32 `duration` generated by [u32_from_24h_duration()]
pub /*const*/ fn duration_from_24h_u32(duration: u32) -> Duration {
    Duration::from_micros(micros_from_24h_u32(duration))
}

/// Returns a human readable "HH:MM:SS.mmmm.µµµ" duration from the 20.1165676116943359375µs time quantum u32 `duration` generated by [u32_from_24h_duration()]
pub fn string_from_24h_u32(duration: u32) -> String {
    let mut micros = micros_from_24h_u32(duration);
    let hours = micros / 3600000000u64;
    micros -= hours * 3600000000u64;
    let minutes = micros / 60000000u64;
    micros -= minutes * 60000000u64;
    let seconds = micros / 1000000u64;
    micros -= seconds * 1000000u64;
    let millis = micros / 1000u64;
    micros -= millis * 1000u64;
    format!("{:02}:{:02}:{:02}.{:03}.{:03}", hours, minutes, seconds, millis, micros)
}

/// Returns an `u32` capable of representing almost 12 hours (precisely 42949.67295 seconds or 11:55:49.67295) from a duration structure,
/// with a time quantum of exact 10µs -- 42949 came from this formula: `s*1e6 / (2^32) = µs_precision`, which resolves to `s=(2^32)/1e5`.\
/// For the reverse operation, see [micros_from_10µs_precision_u32], [duration_from_10µs_precision_u32()] and [systemtime_from_10µs_precision_u32()].\
/// See also [u32_from_24h_duration()] for the full 24h range representation.
pub const fn u32_from_10µs_precision_duration(duration: &Duration) -> u32 {
    const NANOS_IN_TIME_QUANTUM: u32 = 1000 * 10;   // nanos in our 10µs time quantum
    (duration.as_secs() as u32) * 100000 + (duration.subsec_nanos() / NANOS_IN_TIME_QUANTUM)
}

/// Works like [u32_from_10µs_precision_duration()], but allows specifying it as `micros` (from 0 to 42949672950 -- 11:55:49.672950).
pub /*const*/ fn u32_from_10µs_precision_micros(micros: u64) -> u32 {
    const MICROS_IN_TIME_QUANTUM: f64 = 1.0e6 / ((1u64<<32) as f64 / 86400.0);
    ( micros as f64 / MICROS_IN_TIME_QUANTUM ).round() as u32
}

/// Returns the number of microseconds from the 10µs time quantum u32 `duration` generated by [u32_from_10µs_precision_duration()]
pub const fn micros_from_10µs_precision_u32(duration: u32) -> u64 {
    const MICROS_IN_TIME_QUANTUM: u64 = 10;
    duration as u64 * MICROS_IN_TIME_QUANTUM
}

/// Returns the `Duration` struct from the 10µs time quantum u32 `duration` generated by [u32_from_10µs_precision_duration()]
pub const fn duration_from_10µs_precision_u32(duration: u32) -> Duration {
    Duration::from_micros(micros_from_10µs_precision_u32(duration))
}

/// Returns the resulting `SystemTime` struct from the `epoch` added to the 10µs time quantum u32 `duration` generated by [u32_from_10µs_precision_duration()]
pub fn systemtime_from_10µs_precision_u32(duration: u32, epoch: &SystemTime) -> SystemTime {
    epoch.add(duration_from_10µs_precision_u32(duration))
}


#[cfg(any(test,doctest))]
mod tests {
    use super::*;

    /// tests (the almost 24hs range) time conversions to `u32` from a `std::time::Duration` (and vice-versa)
    #[cfg_attr(not(doc),test)]
    fn test_24h_range_from_duration() {
        let valid_durations = [
            Duration::from_micros(0),
            Duration::from_micros(43200 * 1000000),
            Duration::from_micros(86399999960),
        ];
        for original_duration in valid_durations {
            assert_exact_representation("u32_from_24h_duration()",
                                        original_duration,
                                        || u32_from_24h_duration(&original_duration),
                                        duration_from_24h_u32);
        }
        assert_maximum_duration(23, 59, 59, duration_from_24h_u32);
        assert_constant_time_quantum(1, duration_from_24h_u32);
    }

    /// tests (the almost 24h range) time conversions to `u32` from the individual hours, minutes, seconds, millis, micros, ... (and vice-versa)
    #[cfg_attr(not(doc),test)]
    fn test_24h_range_from_parts() {
        let valid_time_parts = [
            ( 0,  0,  0, 0,     0),
            (12,  0,  0,   0,   0),
            (17, 32, 42, 937, 420),
            (23, 59, 59, 980, 970),
        ];
        for (hours, minutes, seconds, millis, micros) in valid_time_parts {
            assert_exact_representation("u32_from_24h_hmsm()",
                                        Duration::from_millis( ((hours as u64) * 3600 + (minutes as u64) * 60 + (seconds as u64)) * 1000 + (millis as u64) ),
                                        || u32_from_24h_hmsm(hours, minutes, seconds, millis),
                                        duration_from_24h_u32);
            assert_exact_representation("u32_from_24h_hmsmm()",
                                        Duration::from_micros( ((hours as u64) * 3600 + (minutes as u64) * 60 + (seconds as u64)) * 1000000 + ((millis as u64) * 1000 + micros as u64) ),
                                        || u32_from_24h_hmsmm(hours, minutes, seconds, millis, micros),
                                        duration_from_24h_u32);
            let micros = ((hours as u64) * 3600 + (minutes as u64) * 60 + (seconds as u64)) * 1000000 + ((millis as u64) * 1000 + micros as u64);
            assert_exact_representation("u32_from_24h_micros()",
                                        Duration::from_micros(micros),
                                        || u32_from_24h_micros(micros),
                                        duration_from_24h_u32);
        }
    }
    
    /// tests 24hs times to string
    #[cfg_attr(not(doc),test)]
    fn test_24h_range_to_string() {
        assert_eq!(string_from_24h_u32(1),                                                 "00:00:00.000.020", "Minimum time quantum check");
        assert_eq!(string_from_24h_u32(u32_from_24h_duration(&Duration::from_millis(1))),  "00:00:00.001.006", "Millis check");
        assert_eq!(string_from_24h_u32(u32_from_24h_duration(&Duration::from_secs(1))),    "00:00:00.999.995", "Seconds check");
        assert_eq!(string_from_24h_u32(u32_from_24h_duration(&Duration::from_secs(60))),   "00:00:59.999.996", "Minutes check");
        assert_eq!(string_from_24h_u32(u32_from_24h_duration(&Duration::from_secs(3600))), "01:00:00.000.007", "Hours check");
    }

    /// tests (the almost 12h range) 10µs precision time conversions to `u32` from a `std::time::Duration` (and vice-versa)
    #[cfg_attr(doctest,test)]
    fn test_10µs_precision_from_duration() {
        let valid_durations = [
            Duration::from_micros(0),
            Duration::from_micros(232010102 * 10),
            Duration::from_micros((11*3600+55*60+49)*1000*1000),
            Duration::from_micros(u32::MAX as u64 * 10),
        ];
        for original_duration in valid_durations {
            assert_exact_representation("u32_from_10µs_precision_duration()", 
                                        original_duration,
                                        || u32_from_10µs_precision_duration(&original_duration),
                                        duration_from_10µs_precision_u32);
        }
        assert_maximum_duration(11, 55, 49, duration_from_10µs_precision_u32);
        assert_constant_time_quantum(0, duration_from_10µs_precision_u32);
    }

    /// tests (the almost 12h range) 10µs precision time conversions to `u32` from the individual hours, minutes, seconds, millis, micros, ... (and vice-versa)
    #[cfg_attr(doctest,test)]
    fn test_10µs_precision_from_parts() {
        let valid_time_parts = [
            ( 0,  0,  0,   0,   0),
            ( 0, 38, 40, 101,  20),
            (11, 55, 49,   0,   0),
            (11, 55, 49, 672, 950),
        ];
        for (hours, minutes, seconds, millis, micros) in valid_time_parts {
            let micros = ((hours as u64) * 3600 + (minutes as u64) * 60 + (seconds as u64)) * 1000000 + ((millis as u64) * 1000 + micros as u64);
            assert_exact_representation("u32_from_10µs_precision_micros()",
                                        Duration::from_micros(micros),
                                        || u32_from_10µs_precision_micros(micros),
                                        duration_from_24h_u32);
        }
    }

    /// exact up to the 10 microseconds (our current precision limit)...
    fn assert_exact_representation(to_u32_op_name:    &str,
                                   original_duration: Duration,
                                   to_u32:            impl Fn()          -> u32,
                                   from_u32:          impl Fn(u32)       -> Duration) {
        let n = to_u32();
        let mut reconverted_duration = from_u32(n);
        println!("Checking the exact representation for durations through '{to_u32_op_name}' {:?} -> {} -> {:?}", original_duration, n, reconverted_duration);
        // remove conversion noise -- information lower than 10 microseconds
        reconverted_duration = Duration::from_micros(10 * (reconverted_duration.as_micros() as u64 / 10));
        assert_eq!(reconverted_duration, original_duration, "Durations don't match for operation '{to_u32_op_name}'");
    }

    /// assures the given `hour`, `minute` and `second` is the maximum possible integer duration
    /// the given `from_u32()` function is capable of representing
    fn assert_maximum_duration(hour: u32, minutes: u32, seconds: u32,
                               from_u32: impl Fn(u32) -> Duration) {
        let expected_maximum_duration = Duration::from_micros(((hour as u64)*3600 + (minutes as u64)*60 + (seconds as u64)) * 1000 * 1000);
        let observed_maximum_duration = from_u32(u32::MAX);
        println!("Checking the maximum durations expression is true: {:?} <= {:?}", expected_maximum_duration, observed_maximum_duration);
        assert!(observed_maximum_duration >= expected_maximum_duration, "Maximum expected duration of {:2}:{:2}:{:2} is outside range -- observed maximum was just {:?}", hour, minutes, seconds, observed_maximum_duration);
        let over_maximum_duration = Duration::from_micros(((hour as u64)*3600 + (minutes as u64)*60 + ((1 + seconds) as u64)) * 1000 * 1000);
        assert!(observed_maximum_duration <= over_maximum_duration, "Informed duration of {:2}:{:2}:{:2} is not the actual maximum, as at least one second further is still within range", hour, minutes, seconds);
    }

    /// assures we have a constant time quantum among sequential u32 numbers with the given +/- `micros_tolerance`
    /// for fractional time quantums
    fn assert_constant_time_quantum(micros_tolerance: u32, from_u32: impl Fn(u32) -> Duration) {
        let range_start = 1<<20;
        let range_end = 1<<21;
        let mut last_micros = from_u32(range_start-1).as_micros();
        let expected_delta = from_u32(range_start).as_micros() - last_micros;
        println!("Assuring time quantum is always {}µs +/- {}µs -- sampled over u32 range {}..{}", expected_delta, micros_tolerance, range_start, range_end);
        for duration in range_start .. range_end {
            let micros = from_u32(duration).as_micros();
            let observed_delta = micros - last_micros;
            let abs_difference = (observed_delta as i64 - expected_delta as i64).abs();
            assert!(abs_difference as u32 <= micros_tolerance, "time quantum changed: observed {} / expected {} (tolerance of +/- {}µs) -- at iteraction #{}; previous duration was {:?} / current is {:?}",
                                                               observed_delta, expected_delta, micros_tolerance, duration-range_start, from_u32(duration-1), from_u32(duration));
            last_micros = micros;
        }
    }

    /// tests our time functions can initialize constants
    #[cfg_attr(not(doc),test)]
    fn const_functions() {
        const HOUR:   u64 = 5;
        const MINUTE: u64 = 42;
        const SECOND: u64 = 59;
        const MILLIS: u64 = 321;
        const MICROS: u64 = 130;
        const DURATION: Duration = Duration::from_micros(MICROS + 1000*MILLIS + 1000000*(SECOND + MINUTE*60 + HOUR*3600));
        // 24h cannot be made const yet, as Rust 1.61 still doesn't allow floating-point arithmetic in const functions
        //const U32_24H_TIME:  u32 = u32_from_24h_duration(&DURATION);
        //const DURATION_FROM_U32_24H_TIME:  Duration = duration_from_24h_u32(U32_24H_TIME);
        const U32_10µs_TIME: u32 = u32_from_10µs_precision_duration(&DURATION);
        const DURATION_FROM_U32_10µs_TIME: Duration = duration_from_10µs_precision_u32(U32_10µs_TIME);

        //assert_eq!(DURATION_FROM_U32_24H_TIME,  DURATION, "Reconstituted const time (from 24h range) failed");
        assert_eq!(DURATION_FROM_U32_10µs_TIME, DURATION, "Reconstituted const time (from 10µs precision) failed");
    }
    

}
