//! Contains utility functions for storing durations of varied ranges and precisions on u32,
//! so as to save space when compared to `std::time::Duration` -- 96bits vs 32bits -> 3x saving.
//!
//! NOTE: The functions receiving `Duration` and returning `u32` will panic with overflow when the
//! provided duration exceeds the maximum range.

use std::{
    ops::Add,
    time::{Duration, SystemTime},
};


/// returns a `u32` capable of representing 24 hours (or exactly 86399.99996 seconds) from a duration structure, with a precision
/// of ~20.117µs (exactly `1/((2^32)/86400)*1e6`µs).\
/// Notice, however, this function is not able to exactly represent regular durations like 17:00:00.0000 -- it will always
/// fall into the closest rounded approximation (in this case, 16:59:59.999993).\
/// For the reverse operation, see [micros_from_24h_u32()].\
/// See [u32_from_10µs_precision_duration()] for a precise 10µs time quantum.
pub fn u32_from_24h_duration(duration: &Duration) -> u32 {
    const NANOS_IN_TIME_QUANTUM: f64 = 1000000000.0 / ((1u64<<32) as f64 / 86400.0);
    ((duration.as_nanos() as f64) / NANOS_IN_TIME_QUANTUM).round() as u32
}

/// works like [u32_from_24h_duration()], but receives `hours`, `minutes`, `seconds` and `millis` individually
pub fn u32_from_24h_hmsm(hours: u8, minutes: u8, seconds: u8, millis: u16) -> u32 {
    const MILLIS_IN_TIME_QUANTUM: f64 = 1000.0 / ((1u64<<32) as f64 / 86400.0);
    ( ( ((hours as f64) * 3600.0 + (minutes as f64) * 60.0 + (seconds as f64)) * 1000.0 + (millis as f64) ) / MILLIS_IN_TIME_QUANTUM ).round() as u32
}

/// returns the number of microseconds from the 20.1165676116943359375µs time quantum u32 `duration` generated by [u32_from_24h_duration()]
pub fn micros_from_24h_u32(duration: u32) -> u64 {
    const MICROS_IN_TIME_QUANTUM: f64 = 1000000.0 / ((1u64<<32) as f64 / 86400.0);
    (duration as f64 * MICROS_IN_TIME_QUANTUM).round() as u64
}

/// returns the `Duration` struct from the 20.1165676116943359375µs time quantum u32 `duration` generated by [u32_from_24h_duration()]
pub fn duration_from_24h_u32(duration: u32) -> Duration {
    Duration::from_micros(micros_from_24h_u32(duration))
}

/// returns a human readable "HH:MM:SS.mmmm.µµµ" duration from the 20.1165676116943359375µs time quantum u32 `duration` generated by [u32_from_24h_duration()]
pub fn string_from_24h_u32(duration: u32) -> String {
    let mut micros = micros_from_24h_u32(duration);
    let hours = micros / 3600000000u64;
    micros -= hours * 3600000000u64;
    let minutes = micros / 60000000u64;
    micros -= minutes * 60000000u64;
    let seconds = micros / 1000000u64;
    micros -= seconds * 1000000u64;
    let millis = micros / 1000u64;
    micros -= millis * 1000u64;
    format!("{:02}:{:02}:{:02}.{:03}.{:03}", hours, minutes, seconds, millis, micros)
}

/// returns an `u32` capable of representing almost 12 hours (precisely 42949.67295 seconds or 11:55:49.67295) from a duration structure,
/// with a time quantum of exact 10µs -- 42949 came from this formula: `s*1e6 / (2^32) = µs_precision`, which resolves to `s=(2^32)/1e5`.\
/// For the reverse operation, see [micros_from_10µs_precision_u32], [duration_from_10µs_precision_u32()] and [systemtime_from_10µs_precision_u32()].\
/// See also [u32_from_24h_duration()] for the full 24h range representation.
pub fn u32_from_10µs_precision_duration(duration: &Duration) -> u32 {
    const NANOS_IN_TIME_QUANTUM: u32 = 1000 * 10;   // nanos in our 10µs time quantum
    (duration.as_secs() as u32) * 100000 + (duration.subsec_nanos() / NANOS_IN_TIME_QUANTUM)
}

/// returns the number of microseconds from the 10µs time quantum u32 `duration` generated by [u32_from_10µs_precision_duration()]
pub fn micros_from_10µs_precision_u32(duration: u32) -> u64 {
    const MICROS_IN_TIME_QUANTUM: u64 = 10;
    duration as u64 * MICROS_IN_TIME_QUANTUM
}

/// returns the `Duration` struct from the 10µs time quantum u32 `duration` generated by [u32_from_10µs_precision_duration()]
pub fn duration_from_10µs_precision_u32(duration: u32) -> Duration {
    Duration::from_micros(micros_from_10µs_precision_u32(duration))
}

/// returns the resulting `SystemTime` struct from the `epoch` added to the 10µs time quantum u32 `duration` generated by [u32_from_10µs_precision_duration()]
pub fn systemtime_from_10µs_precision_u32(duration: u32, epoch: &SystemTime) -> SystemTime {
    epoch.add(duration_from_10µs_precision_u32(duration))
}


#[cfg(any(test, feature = "dox"))]
mod tests {
    use super::*;

    /// tests (the almost 12h range) 10µs precision time conversions to `u32` and vice-versa
    #[cfg_attr(not(feature = "dox"), test)]
    fn test_10µs_precision_functions() {
        let valid_durations = [
            Duration::from_micros(0),
            Duration::from_micros(232010102 * 10),
            Duration::from_micros((11*3600+55*60+49)*1000*1000),
            Duration::from_micros(u32::MAX as u64 * 10)
        ];
        for original_duration in valid_durations {
            assert_exact_representation(original_duration,
                                        u32_from_10µs_precision_duration,
                                        duration_from_10µs_precision_u32);
        }
        assert_maximum_duration(11, 55, 49, duration_from_10µs_precision_u32);
        assert_constant_time_quantum(0, duration_from_10µs_precision_u32);
    }

    /// tests (the almost 24hs range) time conversions to `u32` and vice-versa
    #[cfg_attr(not(feature = "dox"), test)]
    fn test_24h_range_functions() {
        let valid_durations = [
            Duration::from_micros(0),
            Duration::from_micros(43200 * 1000000),
            Duration::from_micros(86399999960)
        ];
        for original_duration in valid_durations {
            assert_exact_representation(original_duration,
                                        u32_from_24h_duration,
                                        duration_from_24h_u32);
        }
        assert_maximum_duration(23, 59, 59, duration_from_24h_u32);
        assert_constant_time_quantum(1, duration_from_24h_u32);

        // test hmsm (hours, minutes, seconds, millis) conversion
        let hours = 17;
        let minutes = 32;
        let seconds = 42;
        let millis = 937;
        let expected_representation = u32_from_24h_duration(&Duration::from_millis(hours as u64 * 3600000 + minutes as u64 * 60000 + seconds as u64 * 1000 + millis as u64));
        let observed_representation = u32_from_24h_hmsm(hours, minutes, seconds, millis);
        assert_eq!(observed_representation, expected_representation, "u32_from_24h_hmsm() didn't work");
    }

    /// tests 24hs times to string
    #[cfg_attr(not(feature = "dox"), test)]
    fn test_24h_range_to_string() {
        assert_eq!(string_from_24h_u32(1),                                                 "00:00:00.000.020", "Minimum time quantum check");
        assert_eq!(string_from_24h_u32(u32_from_24h_duration(&Duration::from_millis(1))),  "00:00:00.001.006", "Millis check");
        assert_eq!(string_from_24h_u32(u32_from_24h_duration(&Duration::from_secs(1))),    "00:00:00.999.995", "Seconds check");
        assert_eq!(string_from_24h_u32(u32_from_24h_duration(&Duration::from_secs(60))),   "00:00:59.999.996", "Minutes check");
        assert_eq!(string_from_24h_u32(u32_from_24h_duration(&Duration::from_secs(3600))), "01:00:00.000.007", "Hours check");
    }

    fn assert_exact_representation(duration: Duration,
                                   to_u32: impl Fn(&Duration) -> u32,
                                   from_u32: impl Fn(u32) -> Duration) {
        let n = to_u32(&duration);
        let reconverted_duration = from_u32(n);
        println!("Checking exact representation for durations {:?} -> {} -> {:?}", duration, n, reconverted_duration);
        assert_eq!(reconverted_duration, duration, "Durations don't match");
    }

    /// assures the given `hour`, `minute` and `second` is the maximum possible integer duration
    /// the given `from_u32()` function is capable of representing
    fn assert_maximum_duration(hour: u32, minutes: u32, seconds: u32,
                               from_u32: impl Fn(u32) -> Duration) {
        let expected_maximum_duration = Duration::from_micros(((hour as u64)*3600 + (minutes as u64)*60 + (seconds as u64)) * 1000 * 1000);
        let observed_maximum_duration = from_u32(u32::MAX);
        println!("Checking the maximum durations expression is true: {:?} <= {:?}", expected_maximum_duration, observed_maximum_duration);
        assert!(observed_maximum_duration >= expected_maximum_duration, "Maximum expected duration of {:2}:{:2}:{:2} is outside range -- observed maximum was just {:?}", hour, minutes, seconds, observed_maximum_duration);
        let over_maximum_duration = Duration::from_micros(((hour as u64)*3600 + (minutes as u64)*60 + ((1 + seconds) as u64)) * 1000 * 1000);
        assert!(observed_maximum_duration <= over_maximum_duration, "Informed duration of {:2}:{:2}:{:2} is not the actual maximum, as at least one second further is still within range", hour, minutes, seconds);
    }

    /// assures we have a constant time quantum among sequential u32 numbers with the given +/- `micros_tolerance`
    /// for fractional time quantums
    fn assert_constant_time_quantum(micros_tolerance: u32, from_u32: impl Fn(u32) -> Duration) {
        let range_start = 1<<20;
        let range_end = 1<<21;
        let mut last_micros = from_u32(range_start-1).as_micros();
        let expected_delta = from_u32(range_start).as_micros() - last_micros;
        println!("Assuring time quantum is always {}µs +/- {}µs -- sampled over u32 range {}..{}", expected_delta, micros_tolerance, range_start, range_end);
        for duration in range_start .. range_end {
            let micros = from_u32(duration).as_micros();
            let observed_delta = micros - last_micros;
            let abs_difference = (observed_delta as i64 - expected_delta as i64).abs();
            assert!(abs_difference as u32 <= micros_tolerance, "time quantum changed: observed {} / expected {} (tolerance of +/- {}µs) -- at iteraction #{}; previous duration was {:?} / current is {:?}",
                                                               observed_delta, expected_delta, micros_tolerance, duration-range_start, from_u32(duration-1), from_u32(duration));
            last_micros = micros;
        }
    }

}