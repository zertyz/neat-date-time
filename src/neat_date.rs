//! Constains utility functions for storing dates (either absolute `u32` or relative `u16`),
//! so as to save space when compared to `chrono::NaiveDate` -- up to 2x saving.

use lazy_static::lazy_static;

/// how many fractional days there are in a year
const LEAP_YEAR_FACTOR: f64 = (400.0*365.0 + 400.0/4.0-400.0/100.0+400.0/400.0) / 400.0;

/// days for each month for non-leap years -- January is #0
const MONTH_DAYS: [u32; 12] = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];

/// days for each month for leap years -- January is #0
const MONTH_DAYS_LEAP_YEAR: [u32; 12] = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];

lazy_static! {
    /// year's completed days when each month starts -- January: #0 = 0, meaning: zero completed days for the year at Jan 1st
    static ref DAYS_UP_TO_MONTH_START: [u32; 12] = [0,1,2,3,4,5,6,7,8,9,10,11]
        .map(|month0| (1..=month0)
            .map(|month| MONTH_DAYS[month-1])
            .sum()
        );

    /// same as [DAYS_UP_TO_MONTH_START], but for leap years
    static ref DAYS_UP_TO_MONTH_START_FOR_LEAP_YEARS: [u32; 12] = [0,1,2,3,4,5,6,7,8,9,10,11]
        .map(|month0| (1..=month0)
            .map(|month| MONTH_DAYS_LEAP_YEAR[month-1])
            .sum()
        );
}

/// returns a `u32` to represent a "naive date" (with no timezone consideration) from
/// the given `year`, `month` and `day`.\
/// See [ymd_from_u32()] for the reverse operation.
pub fn u32_from_ymd(year: u16, month: u8, day: u8) -> u32 {
    let leap_days_since_era_start = ((year-1) / 4 - (year-1) / 100 + (year-1) / 400) as u32;
    let era_days_to_year_start = (leap_days_since_era_start*366) + ((year as u32 - leap_days_since_era_start - 1)*365);

    let year_day = match is_leap_year(year) {
        true  => DAYS_UP_TO_MONTH_START_FOR_LEAP_YEARS.as_ref(),
        false => DAYS_UP_TO_MONTH_START.as_ref(),
    }[month as usize - 1] + (day as u32 - 1);

    era_days_to_year_start + year_day

}

/// returns the `year`, `month` and `day` represented by the give u32 naive `date`.\
/// See [u32_from_ymd()] for the reverse operation.
pub fn ymd_from_u32(date: u32) -> (u16, u8, u8) {
    
    let year0f = date as f64 / LEAP_YEAR_FACTOR;
    let year0 = year0f as u32;
    let leap_days_since_era_start = year0 / 4 - year0 / 100 + year0 / 400;
    let mut year1 = year0 + 1;
    let days_up_to_year_start = (leap_days_since_era_start*366) + ((year1 as u32 - leap_days_since_era_start - 1)*365);

    let year_day = date - days_up_to_year_start;
    let days_to_month_start = if is_leap_year(year1 as u16) {
        DAYS_UP_TO_MONTH_START_FOR_LEAP_YEARS.as_ref()
    } else {
        DAYS_UP_TO_MONTH_START.as_ref()
    };
    let mut month0 = year_day / 31;    // hint to the loop bellow... causing it to loop only once or, on most times, not loop at all
    loop {
        if days_to_month_start[month0 as usize] <= year_day {
            break;
        }
        month0 -= 1;
    }

    let mut day0 = year_day - days_to_month_start[month0 as usize];

    let month_days = if is_leap_year(year1 as u16) {
        MONTH_DAYS_LEAP_YEAR
    } else {
        MONTH_DAYS
    };

    if day0 >= month_days[month0 as usize] {
        day0 -= month_days[month0 as usize];
        month0 += 1;
    }
    if month0 >= 12 {
        month0 -= 12;
        year1 += 1;
    }

    (year1 as u16, month0 as u8 + 1, day0 as u8 + 1)
}

/// returns a human readable "YYYY-MM-DD" date from the given `year`, `month` and `day`
pub fn string_from_ymd(year: u16, month: u8, day: u8) -> String {
    format!("{:04}-{:02}-{:02}", year, month, day)
}

/// returns a human readable "YYYY-MM-DD" date from the u32 `date` generated by [u32_from_ymd()]
pub fn string_from_u32(date: u32) -> String {
    let (year, month, day) = ymd_from_u32(date);
    string_from_ymd(year, month, day)
}

/// returns whether there is a "29th feb" day for the given `year` (starting at year #1)
pub fn is_leap_year(year1: u16) -> bool {
    year1 % 4 == 0 && (year1 % 100 != 0 || year1 % 400 == 0)
}


#[cfg(any(test, feature = "dox"))]
mod tests {
    use super::*;

    /// tests dates to `u32` conversion and vice-versa
    #[cfg_attr(not(feature = "dox"), test)]
    fn naive_date_conversions() {
        let (original_year, original_month, original_day) = (1979, 01, 22);
        let epoch = u32_from_ymd(original_year as u16, original_month as u8, original_day as u8);
        dbg!(epoch);
        let (reconstructed_year, reconstructed_month, reconstructed_day) = ymd_from_u32(epoch);
        assert_eq!((reconstructed_year, reconstructed_month, reconstructed_day), (original_year, original_month, original_day), "naive dates <--> u32 conversions failed");
    }

    /// tests we're able to represent all possible dates (in sequence) up to today
    #[cfg_attr(not(feature = "dox"), test)]
    fn comprehensive_representation() {
        let mut expected_u32_date = 0;
        for year in 1..=2022 {
            let month_days = if is_leap_year(year) {
                MONTH_DAYS_LEAP_YEAR
            } else {
                MONTH_DAYS
            };
            for month in 1..=12 {
                for day in 1..=month_days[month as usize - 1] as u8 {
                    let observed_u32_date = u32_from_ymd(year, month, day);
                    assert_eq!(observed_u32_date, expected_u32_date, "`u32` encoded date value is wrong for date {} while traversing all possible dates", string_from_ymd(year, month, day));
                    let (reconstituted_year, reconstituted_month, reconstituted_day) = ymd_from_u32(observed_u32_date);
                    assert_eq!((reconstituted_year, reconstituted_month, reconstituted_day),
                               (year, month, day), "reconstituted date is wrong while encoding/decoding all possible dates");
                    expected_u32_date += 1;
                }
            }
        }
    }

}